[{"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\index.js":"1","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Create.js":"2","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\About.js":"3","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Landing.js":"4","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Sketchbook.js":"5","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Sketchpad.js":"6","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\SavedSketch.js":"7","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Sketch.js":"8","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Vertex.js":"9","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Edge.js":"10"},{"size":2017,"mtime":1607904006689,"results":"11","hashOfConfig":"12"},{"size":1025,"mtime":1607894287128,"results":"13","hashOfConfig":"12"},{"size":2582,"mtime":1607894287127,"results":"14","hashOfConfig":"12"},{"size":1560,"mtime":1607903149320,"results":"15","hashOfConfig":"12"},{"size":2295,"mtime":1607977185796,"results":"16","hashOfConfig":"12"},{"size":626,"mtime":1607820041670,"results":"17","hashOfConfig":"12"},{"size":194,"mtime":1607820041668,"results":"18","hashOfConfig":"12"},{"size":29898,"mtime":1607897484727,"results":"19","hashOfConfig":"12"},{"size":1330,"mtime":1607820041670,"results":"20","hashOfConfig":"12"},{"size":2585,"mtime":1607820041625,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1vnl804",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"24"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\index.js",[],["44","45"],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Create.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\About.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Landing.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Sketchbook.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Sketchpad.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\SavedSketch.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Sketch.js",["46"],"import React from 'react';\r\nimport './styles/main.css';\r\nimport Vertex from \"./Vertex\";\r\nimport Edge from \"./Edge\";\r\n\r\n//The Pad where the drawing happens\r\nexport default class Sketch extends React.Component{\r\n    constructor(props) {\r\n      super(props);\r\n\r\n      this.vertexRadius = 25 / 2;\r\n      this.edgeWidth = 5;\r\n      this.edgeSpacing = 2.25 * this.edgeWidth;\r\n      this.selectionBorderRadius = 2;\r\n      this.arrowSize = 10;\r\n      this.loopRadius = 25;\r\n      this.padWidth = 750;\r\n      this.padHeight = 500;\r\n      this.windowCenter = [window.innerWidth / 2, window.innerHeight / 2];\r\n      this.padOrigin = [this.windowCenter[0] - this.padWidth / 2, this.windowCenter[1] - this.padHeight / 2];\r\n\r\n      this.selectionColor = 'solid pink';\r\n      this.bridgeColor = 'solid red';\r\n      this.canDrawVertex = true;\r\n      this.isGrabber = false;\r\n      this.displayingCounts = false;\r\n      this.canReceiveKeyboardInput = true;\r\n      this.isBp = 'false';\r\n      this.mouseMoveInitPos = [0, 0];\r\n\r\n      this.vertices = [];\r\n      this.edges = [];\r\n      this.selectedVertices = [];\r\n      this.selectedEdges = [];\r\n      this.bridges = [];\r\n\r\n      const loadSketch = JSON.parse(this.findLoadSketchCookie());\r\n      //expire the cookie\r\n      document.cookie = 'loadSketch=;expires=Thu, 18 Dec 2013 12:00:00 UTC';\r\n      if (loadSketch) {\r\n        //gonna need to recreate some stuff\r\n        this.state = loadSketch;\r\n        this.loadSketch(loadSketch);\r\n      } else {\r\n        this.state = {\r\n          vertices: [],\r\n          vertexIDCount: 0,\r\n          edges: [],\r\n          edgeIDCount: 0,\r\n          name: ''\r\n        }\r\n      }\r\n\r\n      document.addEventListener('keypress', e => this.pressKey(e))\r\n      //update at 33ms = ~30pfs\r\n      setInterval(this.update, 33);\r\n    }\r\n\r\n    render() {\r\n      this.windowCenter=[window.innerWidth/2, window.innerHeight/2];\r\n      this.padOrigin=[this.windowCenter[0]-this.padWidth/2, this.windowCenter[1]-this.padHeight/2];\r\n        return (\r\n            <div id='sketchRoot'>\r\n                <input type='text' placeholder={this.state.name} name='sketchName' onChange={this.renameSketch}\r\n                       onClick={(e)=>this.canReceiveKeyboardInput=false}/>\r\n                <button id='saveSketch' onClick={this.props.saveSketch.bind(this, JSON.stringify(this.state))}>Save\r\n                    Sketch\r\n                </button>\r\n                <div id='pad' onClick={this.drawVertex}>\r\n                    <div id='padData' style={{visibility: this.displayingCounts ? 'visible' : 'hidden'}}>\r\n                        {this.determineBipartite()}\r\n                        v = {this.vertices.length}<br/>\r\n                        e = {this.edges.length} <br/>\r\n                        BP = {this.isBp.toString()} <br/>\r\n                    </div>\r\n                    {this.vertices.map((vertex) => (\r\n                        <Vertex key={vertex.id} vertex={vertex} selectElement={this.selectElement}\r\n                                mouseEnterElement={this.mouseEnterElement} mouseLeaveElement={this.mouseLeaveElement}/>\r\n                    ))}\r\n                    {this.edges.map((edge) => (\r\n                        <Edge key={edge.id} edge={edge} selectElement={this.selectElement}\r\n                              mouseEnterElement={this.mouseEnterElement} mouseLeaveElement={this.mouseLeaveElement}/>\r\n                    ))}\r\n                </div>\r\n                <div id='sketchCommands'>\r\n                    <button id='clearPad' onClick={this.clearPad}>Clear Pad</button>\r\n                    <button id='deleteSelection' onClick={this.deleteSelection}>Delete Selection</button>\r\n                    <button id='deselectAll' onClick={this.deselectAll}>Deselect All</button>\r\n                    <button id='generateEdges' onClick={this.generateEdges}>Generate Edges</button>\r\n                    <button id='loopButton' onClick={this.loopVertices}>Loop</button>\r\n                    <button id='grabber' onClick={this.toggleGrabber}>Grabber</button>\r\n                    <button id='idDegree' onClick={this.toggleDisplayVertexData}>ID's</button>\r\n                    <button id='veCounts' onClick={this.toggleCountsDisplay}>Counts</button>\r\n                    <button id='resetIDs' onClick={this.resetIDs}>Reset ID's</button>\r\n                    <button id='idBridges' onClick={this.identifyBridges}>Bridges</button>\r\n                    <button id='generateArc' onClick={this.generateArc}>Arc</button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    update = () => {\r\n      if (this.isGrabber) {\r\n        const mouseMoveCTX = this.props.mouseMoveCTX();\r\n        if (!mouseMoveCTX) return;\r\n        //loop through selected vertices, reposition, reset state\r\n        const deltas = [mouseMoveCTX.clientX - this.mouseMoveInitPos[0], mouseMoveCTX.clientY - this.mouseMoveInitPos[1]];\r\n        this.mouseMoveInitPos = [mouseMoveCTX.clientX, mouseMoveCTX.clientY];\r\n        for (let i = 0; i < this.selectedVertices.length; i++) {\r\n          //move the vertex\r\n          const x = this.selectedVertices[i].x + deltas[0];\r\n          const y = this.selectedVertices[i].y + deltas[1];\r\n          //check bounds\r\n          const widthCheck = x > 2 * this.vertexRadius && x < this.padWidth - 2 * this.vertexRadius;\r\n          const heightCheck = y > 2 * this.vertexRadius && y < this.padHeight - 2 * this.vertexRadius;\r\n          if (widthCheck) {\r\n            this.selectedVertices[i].x = x;\r\n            this.state.vertices.find((vertex) => vertex.id === this.selectedVertices[i].id).x = x;\r\n          }\r\n          if (heightCheck) {\r\n            this.selectedVertices[i].y = y;\r\n            this.state.vertices.find((vertex) => vertex.id === this.selectedVertices[i].id).y = y;\r\n          }\r\n          //reposition its edges\r\n          this.positionVertexEdges(this.selectedVertices[i]);\r\n        }\r\n        this.setState(this.state);\r\n      }\r\n    }\r\n\r\n    renameSketch=(e)=>{\r\n        const state=this.state;\r\n        state.name=e.target.value;\r\n        this.setState(state);\r\n    }\r\n\r\n    toggleGrabber = () => {\r\n      this.isGrabber = !this.isGrabber;\r\n      this.mouseMoveInitPos = [this.props.mouseMoveCTX.clientX, this.props.mouseMoveCTX.clientY];\r\n    }\r\n\r\n    resetIDs=()=> {\r\n        const state = this.state;\r\n        state.vertexIDCount = 0;\r\n        state.edgeIDCount = 0;\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            this.vertices[i].id = state.vertexIDCount++;\r\n            state.vertices[i].id = this.vertices[i].id;\r\n        }\r\n        for (let i = 0; i < this.edges.length; i++) {\r\n            this.edges[i].id = state.edgeIDCount++;\r\n            state.edges[i].id = this.edges[i].id;\r\n        }\r\n        this.setState(state);\r\n    }\r\n\r\n    pressKey(e) {\r\n      if (!this.canReceiveKeyboardInput)\r\n        return;\r\n      switch (e.code) {\r\n        case 'KeyE':\r\n          //generate edges\r\n          this.generateEdges();\r\n          break;\r\n        case 'KeyG':\r\n          //grabber\r\n          this.toggleGrabber();\r\n          break;\r\n        case 'KeyD':\r\n          //delete selection\r\n          this.deleteSelection();\r\n          break;\r\n        case 'KeyC':\r\n          //toggle pad counts\r\n          this.toggleCountsDisplay();\r\n          break;\r\n        case 'KeyI':\r\n          //toggle vertex data\r\n          this.toggleDisplayVertexData();\r\n          break;\r\n        case 'KeyS':\r\n          //deselect\r\n          this.deselectAll();\r\n          break;\r\n        case 'KeyL':\r\n          //loops\r\n          this.loopVertices();\r\n          break;\r\n        case 'KeyR':\r\n          //reset ID's\r\n          this.resetIDs();\r\n          break;\r\n        case 'KeyB':\r\n          //show bridges\r\n          this.identifyBridges();\r\n          break;\r\n        case 'KeyA':\r\n          //arc\r\n          this.generateArc();\r\n          break;\r\n          //colorings\r\n        case 'Digit1':\r\n          this.colorVertices('black');\r\n          break;\r\n        case 'Digit2':\r\n          this.colorVertices('white');\r\n          break;\r\n        case 'Digit3':\r\n          this.colorVertices('red');\r\n          break;\r\n        case 'Digit4':\r\n          this.colorVertices('orange');\r\n          break;\r\n        case 'Digit5':\r\n          this.colorVertices('yellow');\r\n          break;\r\n        case 'Digit6':\r\n          this.colorVertices('green');\r\n          break;\r\n        case 'Digit7':\r\n          this.colorVertices('blue');\r\n          break;\r\n        case 'Digit8':\r\n          this.colorVertices('purple');\r\n          break;\r\n        case 'Digit9':\r\n          this.colorVertices('brown');\r\n          break;\r\n        case 'Digit0':\r\n          this.colorVertices('cyan');\r\n          break;\r\n      }\r\n    }\r\n\r\n    findLoadSketchCookie(){\r\n      let sketches=decodeURIComponent(document.cookie);\r\n      sketches=sketches.split(';');\r\n      for(let i=0;i<sketches.length;i++){\r\n        const parts=sketches[i].split('=');\r\n        if(parts[0]===' loadSketch'){\r\n          return parts[1];\r\n        }\r\n      }\r\n      return 'null';\r\n    }\r\n\r\n    loadSketch(sketch){\r\n      //build all the vertices first\r\n      for(let i=0;i<sketch.vertices.length;i++){\r\n        this.drawLoadVertex(sketch.vertices[i]);\r\n      }\r\n      //build all the edges\r\n      for(let i=0;i<sketch.edges.length;i++){\r\n        this.drawLoadEdge(sketch.edges[i]);\r\n      }\r\n    }\r\n\r\n    //Selection and Deletion\r\n    selectElement = (isVertex, id) => {\r\n        if (isVertex) {\r\n          //has it already been selected?\r\n          if(this.selectedVertices.find((v)=>v.id===id)){\r\n            return;\r\n          }\r\n            const vertex = this.vertices.find((vertex) => vertex.id === id);\r\n            vertex.isSelected = true;\r\n            this.selectedVertices.push(vertex);\r\n        } else {\r\n          if(this.selectedEdges.find((e)=>e.id===id))\r\n              return;\r\n            const edge = this.edges.find((edge) => edge.id === id);\r\n            edge.isSelected = true;\r\n            this.selectedEdges.push(edge);\r\n        }\r\n        this.setState(this.state);\r\n    }\r\n\r\n    deselectAll = () => {\r\n      //deselect vertices\r\n      for (let i = 0; i < this.selectedVertices.length; i++) {\r\n        this.selectedVertices[i].isSelected = false;\r\n      }\r\n      //deselect edges\r\n      for (let i = 0; i < this.selectedEdges.length; i++) {\r\n        this.selectedEdges[i].isSelected = false;\r\n      }\r\n      this.selectedVertices = [];\r\n      this.selectedEdges = [];\r\n      if (this.isGrabber)\r\n        this.isGrabber = false;\r\n      this.setState(this.state);\r\n    }\r\n\r\n    clearPad = () => {\r\n      //if the grabber is on, turn it off\r\n      if (this.isGrabber) this.toggleGrabber();\r\n      const s = this.state;\r\n      s.vertices = [];\r\n      s.edges = [];\r\n      this.vertices = [];\r\n      this.edges = [];\r\n      this.setState(s);\r\n    }\r\n\r\n    deleteSelection = () => {\r\n      const state = this.state;\r\n      //add all vertex edges to selectedEdges\r\n      for (let i = 0; i < this.selectedVertices.length; i++) {\r\n        for (let j = 0; j < this.selectedVertices[i].edges.length; j++) {\r\n          if (!this.selectedEdges.find(edge => edge.id === this.selectedVertices[i].edges[j])) {\r\n            this.selectedEdges.push(this.selectedVertices[i].edges[j]);\r\n          }\r\n        }\r\n      }\r\n\r\n      //delete edges\r\n      for (let i = 0; i < this.selectedEdges.length; i++) {\r\n        state.edges = state.edges.filter(edge => edge.id !== this.selectedEdges[i].id);\r\n        //remove from connected vertices\r\n        const vertex1 = this.selectedEdges[i].vertex1;\r\n        const vertex2 = this.selectedEdges[i].vertex2;\r\n\r\n        vertex1.edges = vertex1.edges.filter((edge) => edge.id !== this.selectedEdges[i].id);\r\n        if (!this.selectedEdges[i].isLoop) {\r\n          vertex2.edges = vertex2.edges.filter((edge) => edge.id !== this.selectedEdges[i].id);\r\n        }\r\n\r\n        //remove from all edges\r\n        this.edges = this.edges.filter(edge => edge.id !== this.selectedEdges[i].id);\r\n      }\r\n\r\n      //delete all vertices\r\n      for (let i = 0; i < this.selectedVertices.length; i++) {\r\n        state.vertices = state.vertices.filter(vertex => vertex.id !== this.selectedVertices[i].id);\r\n        this.vertices = this.vertices.filter(vertex => vertex.id !== this.selectedVertices[i].id);\r\n      }\r\n\r\n      //recalculate edges\r\n      for (let i = 0; i < this.vertices.length; i++) {\r\n        this.positionVertexEdges(this.vertices[i]);\r\n      }\r\n\r\n      this.selectedVertices = [];\r\n      this.selectedEdges = [];\r\n\r\n      this.setState(state);\r\n    }\r\n\r\n    //Vertex Handling\r\n    drawVertex = (e) => {\r\n      if (this.canDrawVertex) {\r\n        this.canReceiveKeyboardInput = true;\r\n        const state = this.state;\r\n        const vertex = {\r\n          id: state.vertexIDCount++,\r\n          x: e.clientX - this.vertexRadius - this.padOrigin[0],\r\n          y: e.clientY - this.vertexRadius - this.padOrigin[1],\r\n          borderRadius: this.selectionBorderRadius,\r\n          selectionColor: this.selectionColor,\r\n          displayVertexData: this.displayingVertexData,\r\n          edges: [],\r\n          color: 'blue',\r\n          isHovering: false\r\n        }\r\n        const stateVertex = {\r\n          id: vertex.id,\r\n          x: vertex.x,\r\n          y: vertex.y,\r\n          edges: [],\r\n          color: 'blue'\r\n        }\r\n\r\n        this.vertices.push(vertex);\r\n        this.state.vertices.push(stateVertex);\r\n        this.setState(state);\r\n      }\r\n    }\r\n\r\n    drawLoadVertex(stateVertex){\r\n      const vertex={\r\n        id: stateVertex.id,\r\n        x: stateVertex.x,\r\n        y: stateVertex.y,\r\n        borderRadius: this.selectionBorderRadius,\r\n        selectionColor: this.selectionColor,\r\n        displayVertexData: this.displayingVertexData,\r\n        edges: [],\r\n        color: stateVertex.color,\r\n        isHovering: false\r\n      }\r\n      this.vertices.push(vertex);\r\n    }\r\n\r\n    toggleDisplayVertexData=()=> {\r\n        this.displayingVertexData = !this.displayingVertexData;\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            this.vertices[i].displayVertexData = this.displayingVertexData;\r\n        }\r\n        this.setState(this.state);\r\n    }\r\n\r\n    toggleCountsDisplay=()=> {\r\n        this.displayingCounts = !this.displayingCounts;\r\n        this.setState(this.state);\r\n    }\r\n\r\n    colorVertices(color) {\r\n      const state = this.state;\r\n      for (let i = 0; i < this.selectedVertices.length; i++) {\r\n        this.selectedVertices[i].color = color;\r\n        const vertex = state.vertices.find((v) => v.id === this.selectedVertices[i].id);\r\n        vertex.color = color;\r\n      }\r\n      this.setState(state);\r\n    }\r\n\r\n    //Mouse Handling\r\n    mouseEnterElement = (isVertex, id) => {\r\n      this.canDrawVertex = false;\r\n      if (isVertex) {\r\n        //find the vertex tell it that it's hovering\r\n        const vertex = this.vertices.find((v) => v.id === id);\r\n        vertex.isHovering = true;\r\n      } else {\r\n        //same but for edge\r\n        const edge = this.edges.find((e) => e.id === id);\r\n        edge.isHovering = true;\r\n      }\r\n      this.setState(this.state);\r\n    }\r\n\r\n    mouseLeaveElement = (isVertex, id) => {\r\n      this.canDrawVertex = true;\r\n      if (isVertex) {\r\n        //find the vertex tell it that it's hovering\r\n        const vertex = this.vertices.find((v) => v.id === id);\r\n        vertex.isHovering = false;\r\n      } else {\r\n        //same but for edge\r\n        const edge = this.edges.find((e) => e.id === id);\r\n        edge.isHovering = false;\r\n      }\r\n      this.setState(this.state);\r\n    }\r\n\r\n    //Edges\r\n    generateEdges = () => {\r\n        if (this.selectedVertices.length < 2) return;\r\n        for (let i = 0; i < this.selectedVertices.length; i++) {\r\n            for (let j = 0; j < this.selectedVertices.length; j++) {\r\n                //don't draw loops\r\n                //don't wanna draw the same edge twice\r\n                if (i === j || !this.selectedVertices[i].isSelected || !this.selectedVertices[j].isSelected)\r\n                    continue;\r\n\r\n                this.drawEdge(this.selectedVertices[i], this.selectedVertices[j]);\r\n            }\r\n            this.selectedVertices[i].isSelected = false;\r\n        }\r\n\r\n        this.selectedVertices = [];\r\n        this.selectedEdges = [];\r\n\r\n        this.setState(this.state);\r\n    }\r\n\r\n    generateArc=()=> {\r\n      const state = this.state;\r\n      //arcs can only be loops and edges\r\n      if (this.selectedVertices.length !== 1 && this.selectedVertices.length !== 2)\r\n        return;\r\n      let edge;\r\n      //loop or edge?\r\n      if (this.selectedVertices.length === 1) {\r\n        edge = this.drawEdge(this.selectedVertices[0], this.selectedVertices[0]);\r\n      } else {\r\n        edge = this.drawEdge(this.selectedVertices[0], this.selectedVertices[1]);\r\n        edge.targetVertex = this.selectedVertices[1];\r\n      }\r\n      edge.arrowSize = this.arrowSize;\r\n      edge.isArc = true;\r\n      //make the stateEdge an arc too\r\n      const e = state.edges.find((ed) => ed.id === edge.id);\r\n      e.isArc = true;\r\n\r\n      this.positionEdge(edge);\r\n      this.setState(state);\r\n      this.deselectAll();\r\n    }\r\n\r\n    drawEdge = (vertex1, vertex2) => {\r\n      const state = this.state;\r\n      //make the edge\r\n      const edge = {\r\n        id: state.edgeIDCount++,\r\n        vertex1: vertex1,\r\n        vertex2: vertex2,\r\n        borderRadius: this.selectionBorderRadius,\r\n        selectionColor: this.selectionColor,\r\n        isLoop: vertex1.id === vertex2.id,\r\n        loopRadius: this.loopRadius,\r\n        offsetX: 0,\r\n        offsetY: 0,\r\n        zIndex: 1,\r\n        bridgeColor: this.bridgeColor,\r\n        edgeWidth: this.edgeWidth,\r\n        isArc: false,\r\n        isHovering: false\r\n      }\r\n      const stateEdge = {\r\n        id: edge.id,\r\n        vertex1: edge.vertex1.id,\r\n        vertex2: edge.vertex2.id\r\n      }\r\n      vertex1.edges.push(edge);\r\n      //don't add loops twice\r\n      if (!edge.isLoop)\r\n        vertex2.edges.push(edge);\r\n      this.edges.push(edge);\r\n      state.edges.push(stateEdge);\r\n\r\n      //check for parallel Edges\r\n      const parallelEdges = this.parallelEdgeFinder(vertex1, vertex2);\r\n      if (parallelEdges.length > 1) {\r\n        //recalculate parallel Edge positions\r\n        this.calculateEdgeOffsets(parallelEdges, vertex1, vertex2);\r\n        //position all parallel edges\r\n        let z = 9000;\r\n        for (let i = 0; i < parallelEdges.length; i++) {\r\n          //are they loops?\r\n          if (vertex1.id === vertex2.id) {\r\n            parallelEdges[i].zIndex = z--;\r\n          }\r\n          this.positionEdge(parallelEdges[i]);\r\n        }\r\n\r\n      } else {\r\n        //position it\r\n        this.positionEdge(edge);\r\n      }\r\n\r\n      this.setState(state);\r\n      return edge;\r\n    }\r\n\r\n    drawLoadEdge(stateEdge){\r\n      const v1=this.vertices.find((v)=>v.id===stateEdge.vertex1);\r\n      const v2=this.vertices.find((v)=>v.id===stateEdge.vertex2);\r\n      const edge = {\r\n        id: stateEdge.id,\r\n        vertex1: v1,\r\n        vertex2: v2,\r\n        borderRadius: this.selectionBorderRadius,\r\n        selectionColor: this.selectionColor,\r\n        isLoop: v1.id===v2.id,\r\n        loopRadius: this.loopRadius,\r\n        offsetX: 0,\r\n        offsetY: 0,\r\n        zIndex: 1,\r\n        bridgeColor: this.bridgeColor,\r\n        edgeWidth: this.edgeWidth,\r\n        isArc: stateEdge.isArc,\r\n        isHovering: false\r\n      }\r\n      v1.edges.push(edge);\r\n      if(!edge.isLoop) {\r\n        v2.edges.push(edge);\r\n      }\r\n      this.edges.push(edge);\r\n\r\n      //check for parallel Edges\r\n      const parallelEdges = this.parallelEdgeFinder(v1, v2);\r\n      if (parallelEdges.length > 1) {\r\n        //recalculate parallel Edge positions\r\n        this.calculateEdgeOffsets(parallelEdges, v1, v2);\r\n        //position all parallel edges\r\n        let z = 9000;\r\n        for (let i = 0; i < parallelEdges.length; i++) {\r\n          //are they loops?\r\n          if (v1.id === v2.id) {\r\n            parallelEdges[i].zIndex = z--;\r\n          }\r\n          this.positionEdge(parallelEdges[i]);\r\n        }\r\n\r\n      } else {\r\n        //position it\r\n        this.positionEdge(edge);\r\n      }\r\n    }\r\n\r\n    positionEdge = (edge) => {\r\n        if(edge.isLoop) {\r\n            let x = edge.vertex1.x + this.vertexRadius - 2 * this.edgeWidth;\r\n            let y = edge.vertex1.y + this.vertexRadius - 2 * this.edgeWidth;\r\n            if (edge.isSelected) {\r\n                x += 2*this.selectionBorderRadius;\r\n                y += 2*this.selectionBorderRadius;\r\n            }\r\n            edge.x = x;\r\n            edge.y = y;\r\n        }\r\n        else {\r\n            if(edge.isArc && edge.vertex1.id!==edge.targetVertex.id){\r\n                //switcharoo\r\n                const temp = edge.vertex2;\r\n                edge.vertex2 = edge.vertex1;\r\n                edge.vertex1 = temp;\r\n            }\r\n            //math time\r\n            let x1 = edge.vertex1.x;\r\n            let x2 = edge.vertex2.x;\r\n            let y1 = edge.vertex1.y;\r\n            let y2 = edge.vertex2.y;\r\n\r\n            //first, find the height\r\n            let dx = x1 - x2;\r\n            let dy = y2 - y1;\r\n            let height = Math.sqrt((dx * dx) + (dy * dy));\r\n\r\n            //second, find the angle\r\n            let theta = Math.atan2(dx, dy);\r\n\r\n            //third, find the position\r\n            let x = ((x1 + x2) / 2) + edge.offsetX;\r\n            let y = ((y1 + y2) / 2) + edge.offsetY;\r\n\r\n            edge.height = height;\r\n            edge.y = y - (height / 2) + (this.vertexRadius);\r\n            edge.x = x - (this.edgeWidth / 2) + (this.vertexRadius);\r\n            edge.theta = theta;\r\n        }\r\n    }\r\n\r\n    positionVertexEdges(vertex){\r\n        //repositions a moved vertices edges\r\n        //find parallel edge clusters\r\n        let visitedEdges=[];\r\n        for(let i=0;i<vertex.edges.length;i++) {\r\n            if (visitedEdges.find(edge => edge.id === vertex.edges[i].id))\r\n                continue;\r\n            const vertex1 = vertex.edges[i].vertex1;\r\n            const vertex2 = vertex.edges[i].vertex2;\r\n            const parallelEdges = this.parallelEdgeFinder(vertex1, vertex2);\r\n            this.calculateEdgeOffsets(parallelEdges, vertex1, vertex2);\r\n            for (let j = 0; j < parallelEdges.length; j++) {\r\n                visitedEdges.push(parallelEdges[j]);\r\n                this.positionEdge(parallelEdges[j]);\r\n            }\r\n        }\r\n    }\r\n\r\n    loopVertices = () => {\r\n        //loop through selected vertices, adding loops to each\r\n        for (let i = 0; i < this.selectedVertices.length; i++) {\r\n            this.drawEdge(this.selectedVertices[i], this.selectedVertices[i]);\r\n        }\r\n        this.deselectAll();\r\n    }\r\n\r\n    parallelEdgeFinder(vertex1, vertex2) {\r\n        //returns a list of parallel edges between 2 vertices\r\n        let parallelEdges = [];\r\n        for (let i = 0; i < vertex1.edges.length; i++) {\r\n            const vertexA = vertex1.edges[i].vertex1;\r\n            const vertexB = vertex1.edges[i].vertex2;\r\n            if ((vertex1.id === vertexA.id && vertex2.id === vertexB.id)\r\n                || (vertex1.id === vertexB.id && vertex2.id === vertexA.id)) {\r\n                parallelEdges.push(vertex1.edges[i]);\r\n            }\r\n        }\r\n        return parallelEdges;\r\n    }\r\n\r\n    calculateEdgeOffsets(parallelEdges, vertex1, vertex2) {\r\n        //loop check\r\n        if (vertex1.id === vertex2.id) {\r\n            let loopRadius = this.loopRadius;\r\n            for (let i = 0; i < parallelEdges.length; i++) {\r\n                parallelEdges[i].loopRadius = loopRadius;\r\n                loopRadius += this.edgeSpacing;\r\n            }\r\n        } else {\r\n            let slope = (vertex2.y - vertex1.y) / (vertex2.x - vertex1.x);\r\n            slope = -1 / slope;\r\n            //check parity\r\n            const isOdd = parallelEdges.length % 2 === 1;\r\n            let distance = isOdd ? 0 : this.edgeSpacing / 2;\r\n            for (let i = 0; i < parallelEdges.length; i++) {\r\n                //calculate the offsets\r\n                const x = (distance / Math.sqrt(1 + (slope * slope)));\r\n                const y = slope * x;\r\n\r\n                //apply the offsets\r\n                parallelEdges[i].offsetX = x;\r\n                parallelEdges[i].offsetY = y;\r\n\r\n                //increment the magnitude of distance?\r\n                if ((isOdd && i % 2 === 0) || (!isOdd && i % 2 === 1)) {\r\n                    //increment odd sets on even i's and even sets on odd i's\r\n                    let val = Math.abs(distance) + this.edgeSpacing;\r\n                    distance = distance < 0 ? -val : val;\r\n                }\r\n\r\n                distance *= -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    //Advanced Features\r\n    identifyBridges=()=> {\r\n        //loop through edges, remove it. Can I still get from one vertex to the other? add the edge back\r\n        //Currently won't work for digraphs\r\n        this.idBridges = !this.idBridges;\r\n        if (!this.idBridges) {\r\n            //turn off bridge id\r\n            for (let i = 0; i < this.bridges.length; i++) {\r\n                this.bridges[i].isBridge = false;\r\n            }\r\n            this.bridges = [];\r\n        } else {\r\n            //highlight bridges in some color\r\n            //loop through all edges, remove them one at a time. Does the graph become disconnected? If so, it's a bridge\r\n            //check for disconnect via dfs\r\n            for (let i = 0; i < this.edges.length; i++) {\r\n                //remove the edge from its vertices\r\n                //loops can't be bridges\r\n                if (this.edges[i].isLoop)\r\n                    continue;\r\n                const vertex1 = this.edges[i].vertex1;\r\n                const vertex2 = this.edges[i].vertex2;\r\n                vertex1.edges = vertex1.edges.filter((edge) => edge.id !== this.edges[i].id);\r\n                vertex2.edges = vertex2.edges.filter((edge) => edge.id !== this.edges[i].id);\r\n\r\n                //did the removal of this edge disconnect the two vertices?\r\n                const path = this.dfs(vertex1, vertex2);\r\n                if (path.length === 0) {\r\n                    this.edges[i].isBridge = true;\r\n                    this.bridges.push(this.edges[i]);\r\n                }\r\n                //add the edge back in\r\n                vertex1.edges.push(this.edges[i]);\r\n                vertex2.edges.push(this.edges[i]);\r\n            }\r\n        }\r\n        this.setState(this.state);\r\n    }\r\n\r\n    dfs(start, finish) {\r\n        //returns the shortest list of vertices connecting start to finish\r\n        let paths = [];\r\n        this.dfsHelper(start, [], paths, finish);\r\n\r\n        //return the shortest path in paths\r\n        if (paths.length === 0) return paths;\r\n        let shortestPath = paths[0];\r\n        for (let i = 0; i < paths.length; i++) {\r\n            if (paths[i].length < shortestPath.length) {\r\n                shortestPath = paths[i];\r\n            }\r\n        }\r\n        return shortestPath;\r\n    }\r\n\r\n    dfsHelper(currentVertex, path, paths, finish){\r\n        path.push(currentVertex);\r\n        if(currentVertex.id===finish.id){\r\n            paths.push(path);\r\n            return;\r\n        }\r\n        for(let i=0;i<currentVertex.edges.length;i++){\r\n            if(!path.find(v=>v.id===currentVertex.edges[i].vertex1.id)){\r\n                //continue search on vertex1\r\n                this.dfsHelper(currentVertex.edges[i].vertex1, path, paths, finish);\r\n            }\r\n            else if(!path.find(v=>v.id===currentVertex.edges[i].vertex2.id)){\r\n                //continue search on vertex2\r\n                this.dfsHelper(currentVertex.edges[i].vertex2, path, paths, finish);\r\n            }\r\n            //else do nothing for this edge\r\n        }\r\n    }\r\n\r\n    determineBipartite = () => {\r\n        if (this.vertices.length === 0) {\r\n            this.isBp = false;\r\n            return;\r\n        }\r\n        //try to 2 color the sketch\r\n        let visitedVertices = [];\r\n        this.isBp = true;\r\n        while (visitedVertices.length !== this.vertices.length) {\r\n            this.bpHelper(this.vertices[0], 1, visitedVertices);\r\n            if (this.isBp) {\r\n                const unseenVertex = this.findUnseenVertex(visitedVertices);\r\n                this.bpHelper(unseenVertex, 1, visitedVertices);\r\n            } else break;\r\n        }\r\n    }\r\n\r\n    bpHelper(currentVertex, mColor, visitedVertices) {\r\n        if(!currentVertex) return;\r\n        //if it's already determined not bp, then return\r\n        if (this.isBp === false) {\r\n            return;\r\n        }\r\n        //if I've visited this vertex before, I must be trying to color it the same else bad\r\n        if (visitedVertices.length>0 && visitedVertices.find((vertex) => vertex.id === currentVertex.id)) {\r\n            if (currentVertex.mColor !== mColor) {\r\n                this.isBp = false;\r\n            }\r\n            return;\r\n        }\r\n\r\n        //color this vertex\r\n        currentVertex.mColor = mColor;\r\n        visitedVertices.push(currentVertex);\r\n        if (mColor === 1) mColor = 2;\r\n        else mColor = 1;\r\n\r\n        //recurse for all children\r\n        for (let i = 0; i < currentVertex.edges.length; i++) {\r\n            if(currentVertex.edges[i].isLoop)\r\n                continue;\r\n            const adj = this.determineAdjacentVertex(currentVertex, currentVertex.edges[i].vertex1, currentVertex.edges[i].vertex2);\r\n            this.bpHelper(adj, mColor, visitedVertices);\r\n        }\r\n    }\r\n\r\n    determineAdjacentVertex(currentVertex, vertex1, vertex2){\r\n        if(currentVertex.id===vertex1.id)\r\n            return vertex2;\r\n        else\r\n            return vertex1;\r\n    }\r\n\r\n    findUnseenVertex(visitedVertices) {\r\n        let unseenVertices = this.vertices.filter((vertex) => !visitedVertices.find((v) => v.id === vertex.id));\r\n        if (unseenVertices.length === 0) return null;\r\n        return unseenVertices[0];\r\n    }\r\n}","C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Vertex.js",[],"C:\\Users\\Prima\\Documents\\GitHub\\CS320-FP\\graph_theorists_sketchpad\\src\\Edge.js",[],{"ruleId":"47","replacedBy":"48"},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","severity":1,"message":"52","line":160,"column":7,"nodeType":"53","messageId":"54","endLine":232,"endColumn":8},"no-native-reassign",["55"],"no-negated-in-lhs",["56"],"default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-global-assign","no-unsafe-negation"]